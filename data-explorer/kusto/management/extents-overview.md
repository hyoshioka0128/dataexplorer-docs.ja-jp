---
title: エクステント (データ シャード) - Azure データ エクスプローラー |マイクロソフトドキュメント
description: この記事では、Azure データ エクスプローラーのエクステント (データ シャード) について説明します。
services: data-explorer
author: orspod
ms.author: orspodek
ms.reviewer: rkarlin
ms.service: data-explorer
ms.topic: reference
ms.date: 03/13/2020
ms.openlocfilehash: 16afb2dc7d2310e9e63ec3465937ac84c96b27e4
ms.sourcegitcommit: 47a002b7032a05ef67c4e5e12de7720062645e9e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/15/2020
ms.locfileid: "81521014"
---
# <a name="extents-data-shards"></a>エクステント (データシャード)

## <a name="overview"></a>概要

Kusto は、膨大な数のレコード (行) と大量のデータを持つテーブルをサポートするために構築されています。 このような大きなテーブルを処理できるように、Kusto は各テーブルのデータを**データシャード**または**エクステント**と呼ばれる小さな 「タブレット」に分割し(2 つの用語はシノニム)、テーブルのエクステントの和集合がテーブルのデータを保持するようにします。 その後、個々のエクステントは単一ノードの容量よりも小さく保たれ、そのエクステントはクラスターのノードに分散され、スケールアウトを実現します。 

範囲は一種のミニテーブルと考えることができます。 エクステントには、メタデータ (範囲内のデータのスキーマ、および作成時刻や、エクステント内のデータに関連付けられたオプションタグなどの追加情報を示す) とデータが保持されます。 また、通常、エクステントには、エクステント内のデータの各列のインデックス、列データがエンコードされている場合はエンコードディクショナリなど、Kusto が効率的にデータを照会できる情報が保持されます。 したがって、テーブルのデータは、テーブルのエクステント内のすべてのデータの和集合になります。

エクステントは*不変です*。 作成したエクステントは変更されず、エクステントは照会、別のノードへの再割り当て、またはテーブルから除外されるだけです。 データ変更は、1 つ以上の新しいエクステントを作成し、古いエクステントを新しいエクステントとトランザクションで入れ替えることによって行われます。

エクステントは、レコードの集合を保持し、列に物理的に配置します。
この手法 **(columnar ストア**と呼ばれます) を使用すると、データを効率的にエンコードおよび圧縮でき (同じ列の異なる値が互いに似ていることが多いため)、クエリで使用される列だけを読み込む必要があるため、データの大きな範囲に対するクエリがより効率的になります。 内部的には、エクステント内のデータの各列は、セグメントに分割され、セグメントはブロックに分割されます。 この分割 (クエリでは監視できません) を使用すると、Kusto は列の圧縮とインデックス作成を最適化できます。

クエリの効率を維持するために、より小さいエクステントを大きなエクステントにマージします。
これは、構成された[マージ ポリシー](mergepolicy.md)と[シャーディング ポリシー](shardingpolicy.md)に従って、Kusto によってバックグラウンド プロセスとして自動的に実行されます。
エクステントをマージすると、多数のエクステントを追跡する管理オーバーヘッドが軽減されますが、さらに重要なのは Kusto がインデックスを最適化して圧縮を改善できることです。 エクステントのマージは、特定のポイントを超えて範囲をマージすると効率が上がるのではなく、サイズなどの特定の制限に達すると停止します。

[データパーティションポリシー](partitioningpolicy.md)がテーブルに定義されている場合、エクステントは作成後に別のバックグラウンドプロセスを実行します(取り込み後)。 このプロセスは、ソース・エクステントからデータを再取り込みし、*同種*のエクステントを作成します。 *partition key* ポリシーに*ハッシュ パーティション キー*が含まれている場合、同じパーティションに属するすべての同種エクステントがクラスタ内の同じデータ ノードに割り当てられることが保証されます。

> [!NOTE]
> マージ、拡張タグの変更などのエクステント・レベルの操作では、既存のエクステントは変更されません。
> むしろ、既存のソースエクステントに基づいてこれらの操作で新しいエクステントが作成され、その後、これらの新しいエクステントは、単一のトランザクションでそれらの先祖を置き換えます。

したがって、範囲の共通の「ライフサイクル」は次のとおりです。

1. エクステントは**インジェスト**操作によって作成されます。
2. エクステントは他のエクステントとマージされます。 マージされるエクステントが小さい場合、Kusto は実際にそれらのエクステントに対してインジェストプロセスを実行します (これは**rebuild**と呼ばれます)。 エクステントが一定のサイズに達すると、索引に対してのみマージが行われ、ストレージ内のエクステントのデータ成果物は変更されません。
3. マージされたエクステント (他のマージされたエクステントに対する系統を追跡するエクステントなど) は、保持ポリシーのために最終的に削除されます。 エクステントが時間 (古い x 時間/日) に基づいてドロップされると、マージされたエクステント内の最新のエクステントの作成日が計算に取り込まれます。

## <a name="extent-ingestion-time"></a>エクステントインジェスティション時間

各エクステントの情報の重要な部分の 1 つは、その取り込み時間です。 今回は Kusto で次の目的で使用されます。

1. 保持 (以前に取り込まれたエクステントは、以前に削除されます)。
2. キャッシュ (最近取り込まれたエクステントは、より高くなる)
3. サンプリング (などのクエリ操作`take`を使用する場合は、最近のエクステントが優先されます)。

実際、Kusto は範囲`datetime`ごとに 2`MinCreatedOn`つの`MaxCreatedOn`値を追跡します: と .
これらの値は同じ始まりですが、エクステントが他のエクステントとマージされる場合、結果のエクステントの値は、マージされたすべてのエクステントの最小値と最大値になります。

エクステントの取り込み時間は、次の 3 つの方法のいずれかで設定できます。

1. 通常、取り込み処理を実行するノードは、ローカル クロックに従ってこの値を設定します。
2. **取り込み時間ポリシー**がテーブルに設定されている場合、インジェストを実行するノードはクラスターの管理ノードのローカル クロックに従ってこの値を設定し、以降のすべてのインジェストのインジェスト時間値が高くなることを保証します。
3. クライアントはこの時間を設定できます。 (たとえば、クライアントがデータを再取得する必要があり、再び取り込まれたデータが、保存目的で遅れて到着したかのように見せたくない場合などに便利です)。    

## <a name="extent-tagging"></a>エクステントタグ付け

エクステントとともに格納されるメタデータの一部として、Kusto は、複数のオプション*のエクステント タグ*をその範囲にアタッチすることをサポートしています。 エクステント タグ (または単に*タグ*) は、エクステントに関連付けられた文字列です。 [.show extents](extents-commands.md#show-extents)コマンドを使用してエクステントに関連付けられたタグを確認し、[エクステントタグ()](../query/extenttagsfunction.md)関数を使用して、エクステント内のレコードに関連付けられたタグを表示することができます。
エクステント タグを使用すると、範囲内のすべてのデータに関連するプロパティを効率的に記述できます。
たとえば、取り込み中に、取り込むデータのソースを示すエクステント タグを追加し、後でそのタグを使用するとします。 データを記述する場合、2 つ以上のエクステントがマージされると、その関連付けられたタグも、結果のエクステントタグがマージされるエクステントのすべてのエクステントタグの和集合としてマージされます。

Kusto は、値にフォーマット*prefix**プレフィックス**接尾辞*を持つすべてのエクステントタグに特別な意味を割り当てます。

* `drop-by:`
* `ingest-by:`

## <a name="drop-by-extent-tags"></a>'ドロップバイ:' エクステントタグ

プレフィックスで始まるタグ**`drop-by:`** は、他のどのエクステントとマージするかを制御するために使用できます。特定`drop-by:`のタグを持つエクステントはマージできますが、他の範囲とマージされることはありません。 これにより、ユーザーは、次のコマンドのように、タグに従ってエクス`drop-by:`テントをドロップするコマンドを発行できます。

```kusto
.ingest ... with @'{"tags":"[\"drop-by:2016-02-17\"]"}'

.drop extents <| .show table MyTable extents where tags has "drop-by:2016-02-17" 
```

### <a name="performance-notes"></a>パフォーマンスに関する注意事項

* タグの使用`drop-by`を過剰に行うことはお勧めしません。 上記の方法でのデータのドロップのサポートは、めったに発生しないイベントを対象としており、レコードレベルのデータを置き換えるものではなく、この方法でタグ付けされるデータが「かさばる」という事実に大きく依存しています。 レコードごとに異なるタグを付けようとしたり、レコードの数を少ない場合は、パフォーマンスに重大な影響を与える可能性があります。
* このようなタグがデータの取り込み後に一定期間必要ない場合は、[タグを削除](extents-commands.md#drop-extent-tags)することをお勧めします。

## <a name="ingest-by-extent-tags"></a>'取り込み指定:' エクステント タグ

プレフィックスで始まるタグ**`ingest-by:`** を使用すると、データが 1 回だけ取り込まれるようにすることができます。 プロパティを使用して、この特定`ingest-by:`のタグの範囲が既にある場合、データが取り込まれるのを防ぐ INGEST コマンドを**`ingestIfNotExists`** ユーザーが発行できます。
両方`tags`の値と、JSON`ingestIfNotExists`としてシリアル化された文字列の配列です。

次の例では、データを 1 回だけ取り込みます (2 番目と 3 番目のコマンドは何も実行しません)。

```kusto
.ingest ... with (tags = '["ingest-by:2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]')

.ingest ... with (ingestIfNotExists = '["2016-02-17"]', tags = '["ingest-by:2016-02-17"]')
```

> [!NOTE]
> 一般的なケースでは、INGEST コマンドには`ingest-by:`タグと`ingestIfNotExists`プロパティの両方が含まれ、同じ値に設定されます (上記の 3 番目のコマンドに示すように)。

### <a name="performance-notes"></a>パフォーマンスに関する注意事項

- タグの`ingest-by`使用を過度に行うことはお勧めできません。
Kustoに供給するパイプラインにデータの重複が存在することが知られている場合は、データをKustoに取り込む前に可能な限りこれらを解決し、Kustoに摂取する部分が単独で重複を導入する可能性がある場合にのみKustoでタグを使用`ingest-by`することをお勧めします(例えば、すでに進行中のインジェスト呼び出しと重複する可能性のある再試行メカニズムがあります)。 各インジェスト呼び`ingest-by`出しに固有のタグを設定しようとすると、パフォーマンスに重大な影響が及ぶ可能性があります。
- このようなタグがデータの取り込み後に一定期間必要ない場合は、[タグを削除](extents-commands.md#drop-extent-tags)することをお勧めします。